# [缓存](https://doc.webpack-china.org/guides/caching/)

#变动
>   ./build目录为webpack配置目录

>   ./confg/config.js文件为项目配置文件

>   ./dist目录为总资源的输出目录

>   ./src目录为源代码目录

>   1:修改filename属性：[name].[chunkhash].bundle.js，目的用于文件缓存，代码有修改就更新chunkhash值，这样客户端就下载最新的脚本了

>   2:添加CommonsChunkPlugin插件，将在入口entry配置的vendors模块下所有的公共模块都打包到，以入口配置的模块名称vendors进行命名

>   将公共模块都打包到vendors.bundle.js中

>   3:添加CommonsChunkPlugin插件，如果多个模块中都公用了某些模块的代码，就将这些公共模块都打包到runtime.bundle.js文件中

#   目的：

>   1:前端脚本文件没有更新，脚本文件名也没有变化，应该一直会被客户端缓存在客户端本地的，这样就达到了客户端不需要重复下载文件，提高了用户访问速度

>   2:但是，如果脚本文件名不变化的话，客户端会一直首选客户端本地的缓存文件进行读取，我们脚本文件如果有更新，这时候就非常麻烦，无法及时更新到客户端中

>   为了解决这个问题，webpack插件通过将打包的文件进行使用hash值进行命名，也就是output输出口，定义的filename的生成规则中添加chunkhash

>   这样脚本文件有更新的时候，我们打包的话，对应的入口entry定义的模块的输出文件名就会及时更新一个新的hash文件名称，

>   此时，客户端发现下载文件名称有变化就忽略本地缓存，立即选项服务器下载新文件

>   3:但是，如果我们程序中引用了很多公共插件模块，比如lodash,jquery,bootstrp等，

>   这些模块，我们几乎是不用经常更新的，我们经常更新模块，应该都是我们自己写的模块，我们的需求应该是把我们日常维护的模块理解更新到客户端就好了，

>   但是第2步操作，会导致这些公共模块打包文件也会被重新命名一个新的hash，这样会导致客户端，又下载了公共插件模块代码，

>   所以，webpack引入了在入口entry中添加一个公共插件模块的定义，如本案例中的vendors: ['lodash']，

>   他将公共插件模块lodash模块，定义在了入口vendors中，同时，还继续添加了一个CommonsChunkPlugin插件，

>   插件的命名名称与入口中定义的vendors一致，保障入口公共插件模块引用在以vendors.[hash].js文件中

>   同时，webpack也保留另一个CommonsChunkPlugin插件，他的名称为runtime ，它的作用是将我们自己写的模块中，

>   如果很多模块同时都引用了自定义的模块，比如main.js模块引用了print.js模块，detail.js模块也引用了print.js模块，

>   此时print.js模块会被打包到runtime.js模块

>   对于第三点总结的作用是：如果我们修改自己的模块代码，自己的模块的打包命名的hash会立即更新，同时runtime.[hash].js模块也会更新

>   但是公共插件模块不会更新，这样客户端，只会更新我们日常维护的模块，公共插件模块，不会更新。


#   测试方法：

>   我们首先安装本案例   cnpm install

>   执行打包构建命令    cnpm run build_dev

>   然后检查dist目录，被打包的模块的hash值

>   如何我们修改main.js模块的代码，为了测试我们的main.[hash].js文件与runtime.[hash].js文件名称是否更新

>   我们再一次执行打包构建命令   cnpm run build_dev

>   我们在检查main.[hash].js与runtime.[hash].js文件名称，发现文件名称发生变化了

>   但是我们发现公共插件模块vendors.[hash].js的文件名称，并没有变化

>   这样就实现了，日常维护代码会及时更新到客户端，公共插件代码会一直缓冲在客户端本地

>   如果我们日常维护代码不变动，那么客户端也不会重复下载维护代码。

>   这样就实现了用户不会重复下载日常维护代码与插件代码，提高了访问速度

>   同时也实现了我们维护代码有更新，客户端也会及时发现，去下载新代码。


#构建命令
```bash
    
    //启动开发模式，并且浏览器时时更新修改代码
    //缺点是无法观察打包好之后的代码，所以我个人新建了一个build_dev命令，模拟打包开发环境代码
    cnpm run start
    
    //使用这个测试开发模式---代码不压缩
    cnpm run build_dev
    
    //使用这个测试生产模式---代码会压缩
    cnpm run build
```
